\documentclass{article}

\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage[usenames]{color}
\usepackage{hyperref}
  \hypersetup{
    colorlinks = true,
    urlcolor = blue,       % color of external links using \href
    linkcolor= blue,       % color of internal links
    citecolor= blue,       % color of links to bibliography
    filecolor= blue,        % color of file links
    }

\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=haskell,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\theoremstyle{theorem}
   \newtheorem{theorem}{Theorem}[section]
   \newtheorem{corollary}[theorem]{Corollary}
   \newtheorem{lemma}[theorem]{Lemma}
   \newtheorem{proposition}[theorem]{Proposition}
\theoremstyle{definition}
   \newtheorem{definition}[theorem]{Definition}
   \newtheorem{example}[theorem]{Example}
\theoremstyle{remark}
  \newtheorem{remark}[theorem]{Remark}


\title{CPSC-402 Report\\Compiler Construction}
\author{Aidan Wall \\ Chapman University}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Short  summary of purpose and content.
\end{abstract}

\tableofcontents

% \section{Introduction}\label{intro}

% Replace this entire Section~\ref{intro} with your own short introduction.

% \subsection{General Remarks}

% First you need to \href{https://www.latex-project.org/get/}{download and install} LaTeX.\footnote{Links are typeset in blue, but you can change the layout and color of the links if you locate the  \texttt{hypersetup} command.}
% %
% For quick experimentation, you can use an online editor such as \href{https://www.overleaf.com/learn}{Overleaf}. But to grade the report I will used the time-stamped pdf-files in your git repository.


% \medskip\noindent
% LaTeX is a markup language (as is, for example, HTML). The source code is in a \verb+.tex+ file and needs to be compiled for viewing, usually to \verb+.pdf+.


% \medskip\noindent
% If you want to change the default layout, you need to type commands. For example, \verb+\medskip+ inserts a medium vertical space and \verb+\noindent+ starts a paragraph without indentation.

% \medskip\noindent
% Mathematics is typeset between double dollars, for example $$x+y=y+x.$$


% \subsection{LaTeX Resources}

% I start a new subsection, so that you can see how it appears in the table of contents.

% \subsubsection{Subsubsections}

% Sometimes it is good to have subsubsections.

% \subsubsection{Itemize and enumerate}

% \begin{itemize}
% \item This is how you itemize in LaTeX.
% \item I think a good way to learn LaTeX is by starting from this template file and build it up step by step. Often stackoverflow will answer your questions. But here are a few resources:
%   \begin{enumerate}
%   \item \href{https://www.overleaf.com/learn/latex/Learn_LaTeX_in_30_minutes}{Learn LaTeX in 30 minutes}
%   \item \href{https://www.latex-project.org/}{LaTeX – A document preparation system}\end{enumerate}
% \end{itemize}

% \subsubsection{Typesetting Code}

% A typical project will involve code. For the example below I took the LaTeX code from \href{https://stackoverflow.com/a/3175141/4600290}{stackoverflow} and the Haskell code from \href{https://hackmd.io/@alexhkurz/HylLKujCP}{my tutorial}.

% \begin{lstlisting}
% -- run the transition function on a word and a state
% run :: (State -> Char -> State) -> State -> [Char] -> State
% run delta q [] = q
% run delta q (c:cs) = run delta (delta q c) cs
% \end{lstlisting}
% %
% Short snippets such as \texttt{run :: (State -> Char -> State) -> State -> [Char] -> State} can also be directly fitted into text. There are several ways of doing this, for example, \verb@run :: (State -> Char -> State) -> State -> [Char] -> State@ is slightly different in terms of spaces and linebreaking (and can lead to layout that is better avoided), as is
% \begin{verbatim}run :: (State -> Char -> State) -> State -> [Char] -> State\end{verbatim}

% \noindent
% For more on the topic see \href{https://www.overleaf.com/latex/examples/code-presentations-example-different-ways-shown-in-beamer-metropolis/tsxpnyjbhbds}{Code-Presentations Example}.

% \medskip\noindent
% Generally speaking,  the methods for displaying code discussed above work well only for short listings of code. For entire programs, it is better to have external links to, for example, Github or \href{https://replit.com/@alexhkurz/automata01#main.hs}{Replit} (click on the "Run" button and/or the ``Code" tab).

% \subsubsection{Including Graphics}

% By way of example, I include here a screenshot from the book \cite{Hopcroft}.

% \includegraphics{automaton-example.png}

% \noindent
% You can use the same technique to include any handwritten drawings.

% \subsubsection{More Mathematics}

% We have already seen $x+y=y+x$ as an example of inline maths. We can also typeset mathematics in display mode, for example
% $$\frac x y =\frac{xy}{y^2},$$

% \noindent
% Here is an example of equational reasoning that spans several lines:
% \begin{align*}
% {\rm fib}(3)
% & = {\rm fib}(1) +{\rm fib}(2)  & {\rm fib}(n+2) = {\rm fib}(n)  + {\rm fib}(n+1) \\
% & = {\rm fib}(1) +{\rm fib}(0)  + {\rm fib}(1) & {\rm fib}(n+2) = {\rm fib}(n)  + {\rm fib}(n+1) \\
% & = 1 + 0  +1 & {\rm fib}(0) = 0,   {\rm fib}(1) = 1\\
% & = 2 & {\rm arithmetic}
% \end{align*}

% \subsubsection{Definitons, Examples, Theorems, Etc}

% \begin{definition}
% This is a definition.
% \end{definition}

% \begin{example}
% This is an example.
% \end{example}

% \begin{proposition}
% This is a proposition.
% \end{proposition}

% \begin{theorem}
% This is a theorem.
% \end{theorem}

% \noindent You can also create your own environment, eg if you want to have Question, Notation, Conjecture, etc.

% \subsection{Plagiarism}

% To avoid plagiarism, make sure that, in addition to my course notes, you also cite all the external sources you use. Make sure you cite your references throughout your text, not only at the end.

\section{Homework}\label{homework}

% This section will contain your solutions to homework.

% \subsection{Week 1}

For most weeks, you will have a subsection that contains your answers.

\subsection{Week 1}
\textbf{Exercise 2.2.4} Give DFA's accepting the following language over the alphabet 0,1:

b) The set of all strings with three consecutive 0's (not necessarily at)
\\
\includegraphics[scale=.2]{Wall402Ass1.pdf}
\\
c) The set of strings with 011 as a substring.
\\
\includegraphics[scale = 0.4]{IMG_7570.jpg}
% \ldots
%
\subsection{Week 2}
\textbf{Exercise 2.3.4} Find NFA's that recognize:

a) The set of strings over alphabet {0,1,...,9} such that the final digit has appeared:
\\
\includegraphics[scale = .5]{2.3.4A.pdf}

\\
b) The set of strings over alphabet {0,1,...,9} such that the final digit has not appeared before.
\\
\includegraphics[scale=.5]{2.3.4B.pdf}
\\
c) The set of strings of 0's and 1's such that there are two 0's separated by a number of positions that is a multiple of 4. Note that 0 is an allowable multiple of 4.
\\
\includegraphics[scale=.2]{2.3.4C.pdf}
\\


\textbf{Exercise 2.5.3} Find NFA's that recognize

a) The set of strings consisting of zero or more a's followed by zero or more b's, followed by zero or more c's
\\
\includegraphics[scale=.3]{2.5.3A.pdf}
\\

b) The set of strings that consist of either 01 repeated one or more times or 010 repeated one or more times
\\
\includegraphics[scale = .25]{2.5.3B.pdf}
\\
c) The set of strings 0's and 1's such that at least one of the last ten positions is a 1
\\
\includegraphics[scale = .17]{2.5.3C.pdf}


\subsection{Week 3}
\textbf{Exercise 2.3.1} Convert to a DFA the following NFA:
\\
\includegraphics[scale = .4]{2.3.1.jpeg}
\\
converted:
\\
\includegraphics[scale=.2]{2.3.1DFA.pdf}
\\
\textbf{Exercise 2.3.2} Convert to a DFA the following NFA:
\\
\includegraphics[scale=.4]{2.3.2.jpeg}
\\
converted:
\\
\includegraphics[scale=.2]{New2.3.2.pdf}
\\

\\
\textbf{Converting NFAs to DFAs In Haskell Using the List Monad:}
\\
\/
\includegraphics[scale=.4]{week3code.jpeg}
\\
Explanation:
The goal is to write an algorithm that will convert an NFA to a DFA. Because the states of the DFA are sets of states of the NFA, we will need to do this many times, which we will do iteratively in dfa\_final. dfa\_initial has the initial state of the sets, which will contain the initial state of the NFA as list as the only element. dfa\_final will have will only be final when it is a final state of the NFA, which we can get from the code already provided. dfa\_delta uses the Haskell concat function to concatenate all of the sets together.



\subsection{Week 4}
\textbf{Write out the abstract syntax tree for the complete fibonacci program}

\\
\includegraphics[scale = .6]{402week4.pdf}
\\

\textbf{Write out the parse tree (=concrete syntax tree) for the complete fibonacci program:}
\\

% \includegraphics[scale = .6]{week4.pdf}
\\
\includegraphics[scale = .145]{w4.jpeg}

\subsection{Week 10}
1) Show in the form of a proof tree, the steps taken by an interpreter evaluating the following program fragment:


\begin{lstlisting}
int x;
{
x=2;
bool x = false && x;
y = y++ + ++y ;
}
\end{lstlisting}
\\
The proof tree for this program fragment:
\\
\includegraphics[scale = .2]{Week10AST.jpeg}


\\




\section{Project}
% Choose a programming language (such as C) and a compiler (such as gcc) and compile example programs to assembly and explain in some detail

% how the compilation works and
% how the assembly program is executed on the machine.
% For the first deadline, you need to have made a choice of programming language and compiler and show me a program in the source language (C, Java, ...) and the target language (assembly, JVM, ...) that you want to explain. (What about Python?)

% For the second deadline, you need to think how to best explain, at the hand of examples, which parts of the source code correspond to which part of the assembly code. Remember that compilation works by recursion over abstract syntax. You don't need to dig into how exactly the AST looks like, but your general knowledge about ASTs should help you to construct a high level mapping and explain it in your example.

% My recommendation would be to find the source code example that gives the smallest assembly example. Starting from there then to incrementally look at more complicated examples. This should help with constructing and explaining the mapping from source code to assembly.\\

\\
\\


I will be doing the first option of describing and analyzing a compiler in C++ using gcc. I will have a sample program in C++ and convert it to assembly language. I will explain how the compiler is converting the C++ code into assembly language. The program I have chosen will calculate the cube of a number. A cube is a number multiplied by itself 3 times.
\\
\\
Lets first start off by talking about compilers a little bit in general. A compiler is a program that takes programs written in a high level language and transforms them to programs that the computer can understand. It will convert every variable, function, syntax, and everything else. The compiler makes use of a stack to constantly use and update memory registers. A register is simply a small bit of memory inside of the CPU. They are used by assembly language and can perform a variety of tasks. Registers accept, store, and transfer data and instructions from the CPU. All of these registers and data are stored on the stack. The stack is really useful when controlling registers and subroutines because it is very easy to keep track of the point where each active process should return control when it has completed its task.
\\
\\
The program that I am going to convert into assembly is as follows:


% the main reason for having one is to keep track of the point to which each active subroutine should return control when it finishes executing.
%  rbp and rsp; these are special purpose registers. rbp is the base pointer, which points to the base of the current stack frame, and rsp is the stack pointer, which points to the top of the current stack frame.




% Register allocation

% \cite{CPP}
\lstset{language = C++}
\begin{lstlisting}
#include <iostream>
using namespace std;

int cube(int num){

return num * num * num;

}

int main () {
return cube(3);
}


\end{lstlisting}


The most basic version of our program, is just an empty function that returns 0. We I have modified the code so that my cube function just returns 0. It looks like this:

\begin{lstlisting}
int cube(){
return 0;
}
\end{lstlisting}

This is what the output looks like in assembly:
\\

\begin{lstlisting}
cube():
    push    rbp
    mov     rbp, rsp
    mov     eax, 0
    pop     rbp
    ret
\end{lstlisting} \cite{GODBOLT}
% https://www.recurse.com/blog/7-understanding-c-by-learning-assembly
When looking at the first line of both the C++ code and the assembly code we see that the first thing in both is the function cube()\cite{FASS}. This is called the header in assembly.
\\
\\
The next line: \textbf{push rbp}. rbp registers are special purpose registers, which is the base pointer, which points to the base of the current stack frame. By pushing the rbp register first, it puts this register at the top of the stack.
\\
\\
The next line \textbf{mov rbp, rsp}, now has a rsp register, which is the stack pointer, which points to the top of the current stack frame\cite{ASRC}. This line copies the value of the stack pointer rsp to the base pointer rbp, so that now both of these registers point to the value on the top of the stack \cite{SARC}.
\\
\\
The next line \textbf{mov eax, 0} uses a general purpose register eax. This line copies the value 0 into the eax register. In this version of assembly, a functions return value is stored in the eax register. This function sets the return value to 0 at the end of our function. This is directly the line \textbf{return 0;} in our C++ code \cite{ASRC}.
\\
\\
The second to last line \textbf{pop rbp} pops off the base pointer that is currently on the top of the stack, off the stack, and stores it back into the rbp register. The rbp has to be popped off because we pushed it earlier in the program. Anything that is put on the stack also has to be removed from the stack, otherwise the program will crash.
\\
\\
The last line \textbf{ret} pops the return address from the top of the stack. This happens when functions are called, and the program uses this call to push the return address before it actually executes any of the instructions in the function. \\
\\
Now that we have seen the bone structure for a simple conversion from a C++ function to assembly, next I will convert the entire function to cube a number into assembly, and can take a look at the difference:

The code for our C++ function is as follows:
\begin{lstlisting}
int cube(int num){
return num * num * num;
}
\end{lstlisting}

The outputted assembly code for this C++ function is as follows:
\begin{lstlisting}
cube(int):
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-4], edi
    mov     eax, DWORD PTR [rbp-4]
    imul    eax, eax
    imul    eax, DWORD PTR [rbp-4]
    pop     rbp
    ret
\end{lstlisting} \cite{GODBOLT}
\\
There are a couple differences in output between the basic empty function and this function. In the header, \textbf{cube(int)} there is now an being passed in to the function. It is of the type int and is the variable \textbf{num} in our C++ function. The next two lines \textbf{push rbp} and \textbf{mov rbp, rsp} are the same as the previous program. They just set the register to the top of the stack and points the registers to it.
\\
\\
The next line \textbf{mov DWORD PTR [rbp-4], edi} is one that was not in the previous program but is now. This line is in reference to the argument passed to our cube function. It is storing the integer argument num, into the edi register. An edi register is a destination index register used for strings, memory array copying and setting. This line is copying the num argument locally (with an offset of -4 bytes from the frame pointer stored in the rbp \cite{PTR}.
\\
\\
The following line \textbf{mov eax, DWORD PTR [rbp-4]} copies the value in the local register to the eax register.
\\
\\
The next line \textbf{imul eax eax} uses the built in imul function, which executes a signed multiplication of a register by a register and stores the product in a register \cite{IMUL}. In this case, it is multiplying the eax register, which has the stored value of the passed "num" argument, with itself, the eax register.
\\
\\
The previous line squared the number, but the number needs to be cubed. The line \textbf{imul eax, DWORD PTR [rbp-4]} multiplies the already squared value of eax, with the value at the position of rbp-4, where the original value of our argument was stored\cite{IMUL}. This completes the cubing of the number, and \textbf{pop rbp} is called to store the value back in the rbp register. This is the same as the previous example, and will always be done when it is pushed earlier in the program. The last line pops the return address from the top of the stack and completes the program.
\\
\\
The next part, and the most important, of converting a C++ code to assembly is the main function. To start from the beginning, I will explain a simple main function so we can understand how the framework works. Our C++ main function does nothing and returns 0:
\begin{lstlisting}
int main() {
return 0;
  }
\end{lstlisting}

This simple main function in C++ in assembly is:
\begin{lstlisting}
main:
    push    rbp
    mov     rbp, rsp
    mov     eax, 0
    pop     rbp
    ret
\end{lstlisting} \cite{GODBOLT}
\\
\\
The only difference between this function and the one I showed earlier is the header is different. This one is header for the program called main instead of cube.
\\
When combining all of this together, we declare the cube function, then build our main and call the cube function on the number 5. The final C++ program looks like this:
\begin{lstlisting}
int cube(int num) {
    return num * num * num;
}

int main(){
    return cube(5);
}
\end{lstlisting}

The final output for our assembly code is as follows:
\begin{lstlisting}
cube(int):
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-4], edi
    mov     eax, DWORD PTR [rbp-4]
    imul    eax, eax
    imul    eax, DWORD PTR [rbp-4]
    pop     rbp
    ret
main:
    push    rbp
    mov     rbp, rsp
    mov     edi, 5
    call    cube(int)
    nop
    pop     rbp
    ret
\end{lstlisting}

When looking at this output of main vs the previous output of main, there are 3 differences with 2 of them being additional lines. In the previous main, the value 0 was set to the eax register. In this, the int value 5 is being set to the edi register. The eax register used before is for temporary data storage and memory access. The edi, destination index register, is being used here instead, with the value 5 being given to it \cite{x86}. There are also two additional lines that were not there before, they are:
\\
\\ \textbf{call cube(int)}
\\ \textbf{nop}
\\
\\
The line \textbf{call cube(int)} uses the keyword "call" and calls the function cube, with an int as an argument. The function can later return using 'ret' at the end. Call will store the return address to jump back onto the stack \cite{FASS}.
\\
\\
The next new line \textbf{nop} is a no operation, which is an instruction that doesn't implement any sort of operation.

no-op instructions are used for timing purposes. They can also help to deal with certain memory issues, or work in conjunction with a group of other instructions to facilitate some kind of end result. No-op instructions may be used for pipeline synchronization or to delay some type of CPU activity.

A no operation or “no-op” instruction in an assembly language is an instruction that does not implement any operation \cite{TECHNOPEDIA}. No-op's are often used for timing purposes, often to delay an instruction, or to help with memory issues, and a variety of other things.
\\

The code ends as how every other one of the assembly code has ended. Popping the rpb register with the stored value of 125 (5*5*5) and then returns it, breaking the call function and terminating our program.
\\
\\
% Now a full program has been implemented, from the basic bones of a simple C++ program, to defining a function, to then calling that function and returning a value.


\medskip\noindent


\section{Conclusions}\label{conclusions}
Compilers are the magical bridge between the brilliance of programmers and the brilliance of computers. They allow programmers all over the world to write code in high level languages and build things with ease. If programmers had to interact with machine code themselves and did not have compilers, we would not be where we are today technologically. They bridge the gap between software and hardware, and allow people to specialize in one aspect of this so that they can be more efficient. However, building a compiler is no easy task. It draws ideas from discrete math, linear algebra, programming language theory, computer architecture, electrical engineering, and so many other disciples. Compilers have been a very important important of scientific history, and have allowed us to do so much. I am glad that I got to learn more about the intricacies of a compiler, and it has made me view programming in a different light. I now understand different errors better, and what I can and cannot do when writing code.

\begin{thebibliography}{99}
\bibitem[HMU]{Hopcroft}
	John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman:
\href{http://ce.sharif.edu/courses/94-95/1/ce414-2/resources/root/Text%20Books/Automata/John%20E.%20Hopcroft,%20Rajeev%20Motwani,%20Jeffrey%20D.%20Ullman-Introduction%20to%20Automata%20Theory,%20Languages,%20and%20Computations-Prentice%20Hall%20(2006).pdf}{Introduction to automata theory, languages, and computation,} 3rd Edition. Pearson international edition, Addison-Wesley 2007

\bibitem[CPP]{CPP} \href{https://www.programiz.com/cpp-programming/examples/prime-number}{Intro C++ Program}

\bibitem[FASS]{FASS}
\href{https://www.cs.uaf.edu/2015/fall/cs301/lecture/09_14_call.html}{Calling Functions in Assembly}

\bibitem[IMUL]{IMUL}
\href{https://docs.oracle.com/cd/E19455-01/806-3773/instructionset-39/index.html#:~:text=The%20single%2Doperand%20form%20of,or%20EDX%3AEAX%20register%20respectively.}{Oracle IMUL Documentation}

\bibitem[x86]{x86}
\href{https://www.eecg.utoronto.ca/~amza/www.mindsec.com/files/x86regs.html#:~:text=ES%3AEDI%20EDI%20DI%20%3A%20Destination,ESP%20ESP%20SP%20%3A%20Stack%20pointer}{x86 Registers}

\bibitem[PTR]{PTR}
\href{https://stackoverflow.com/questions/45375282/understanding-c-program-in-assembly}{Understanding Assembly in C}


\bibitem[GODBOLT]{GODBOLT}
\href{https://godbolt.org/}{C++ to web assembly}
\bibitem[SARC]{SARC}
\href{https://blog.holbertonschool.com/hack-virtual-memory-stack-registers-assembly-code/#:~:text=The%20first%20lines%20of%20the,of%20the%20current%20stack%20frame.}{Stack Register Assembly Code}

\bibitem[ASRC]{ASRC}
\href{https://www.recurse.com/blog/7-understanding-c-by-learning-assembly}{Understanding C by Learning Assembly}


\bibitem[TECHNOPEDIA]{TECHNOPEDIA}
\href{https://www.techopedia.com/definition/11989/no-operation-nop#:~:text=No%20Operation%20(NOP)-,What%20Does%20No%20Operation%20(NOP)%20Mean%3F,a%20blank%20instruction%20or%20placeholder.}{What Are "No-Ops"?}
\end{thebibliography}



\end{document}
